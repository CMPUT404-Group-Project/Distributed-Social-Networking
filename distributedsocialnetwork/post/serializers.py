# Serializers for Posts and Comments
from rest_framework import serializers

from .models import Post, Comment

from author.models import Author
from author.serializers import AuthorSerializer

from json import loads, dumps

from django.core.paginator import Paginator
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response


class CommentSerializer(serializers.ModelSerializer):
    # Serializes a comment in the way the API specifies.
    author = serializers.SlugRelatedField(
        queryset=Author.objects.all(), slug_field='id')
    # Allows us to overwrite the autogenerated UUID, for POST
    id = serializers.UUIDField()
    published = serializers.DateTimeField()

    class Meta:
        model = Comment
        fields = ['author', 'comment', 'contentType',
                  'post_id', 'published', 'id']

    # # For representing authors properly
    # # Thanks to Sardorbek Imomaliev: https://stackoverflow.com/a/50257132
    def to_representation(self, instance):
        self.fields['author'] = AuthorSerializer(read_only=True)
        return super(CommentSerializer, self).to_representation(instance)

    # def create(self, validated_data):
    #     return Comment.objects.create(**validated_data)

    # def update(self, instance, validated_data):
    #     instance.author = validated_data.get('author', instance.author)
    #     instance.comment = validated_data.get('comment', instance.comment)
    #     instance.contentType = validated_data.get(
    #         'contentType', instance.contentType)
    #     instance.post_id = validated_data.get("post_id", instance.post_id)
    #     instance.id = validated_data.get("id", instance.id)
    #     instance.published = validated_data.get(
    #         "published", instance.published)
    #     instance.save()
    #     return instance

    def validate(self, data):
        # We will perform a few checks, and then call the super to do the rest
        # Is the Post ID correct?
        post_pk = self.context["pk"]
        print(data)
        if post_pk != data["post_id"].id:
            raise serializers.ValidationError(
                "You cannot post a comment to a different post. ID given was " + str(data["post_id"].id) + ' and URI was for '+str(post_pk))
        # Have we already used this PostID before? This is via POST so we should not be.
        if (Comment.objects.filter(id=data["id"])).count() == 1:
            raise serializers.ValidationError(
                "That comment id is already in use")
        return super(CommentSerializer, self).validate(data)


class PostSerializer(serializers.ModelSerializer):
    # Serializes a post in the way the API specifies.
    # author = AuthorSerializer()
    author = serializers.SlugRelatedField(
        queryset=Author.objects.all(), slug_field='id')

    class Meta:
        model = Post
        fields = ['title', 'source', 'origin', 'description', 'contentType',
                  'content',  'author', 'categories', 'published',
                  'visibility', 'id', 'visibleTo']

    # For representing authors properly
    # Thanks to Sardorbek Imomaliev: https://stackoverflow.com/a/50257132

    def to_representation(self, instance):
        self.fields['author'] = AuthorSerializer(read_only=True)
        return super(PostSerializer, self).to_representation(instance)

    def create(self, validated_data):
        return Post.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.title = validated_data.get('title', instance.title)
        instance.source = validated_data.get('source', instance.source)
        instance.origin = validated_data.get('origin', instance.origin)
        instance.description = validated_data.get(
            'description', instance.description)
        instance.contentType = validated_data.get(
            'contentType', instance.contentType)
        instance.content = validated_data.get('content', instance.content)
        instance.author = validated_data.get('author', instance.author)
        instance.visibility = validated_data.get(
            'visibility', instance.visibility)
        instance.save()
        return instance
